#!/usr/bin/env python

import glob
import concurrent.futures
from pathlib import Path
import shutil
import argparse

import uproot
import numpy as np
import tqdm

# tree = "MMTriggerData"
# path = "MMImages.root"
# branch = "MM_Image"
# chunksize = 100

def get_tree_entries(path, tree):
    with uproot.open(path) as file:
        tree = file[tree]
        n_events = tree.num_entries
    return n_events


def run(kwargs: dict):
    slc = kwargs["slc"]
    root_file = uproot.open(kwargs["file"])
    t = root_file[kwargs["tree"]].arrays(library="ak", 
                                        entry_start=slc[0], 
                                        entry_stop=slc[1])\
                                            [kwargs["branch"]]
    img = t.to_numpy()
    out_path = f"{kwargs['tmp_dir']}/img{kwargs['no']:04d}"
    np.save(out_path, img)
    return f"Saved file: {out_path}"


def merge(tmp_dir, fname):
    files = glob.glob(str(tmp_dir)+"/*")
    files.sort()
    imgs = [np.load(f) for f in files]
    data = np.concatenate(imgs)
    np.savez(fname, MM_Image=data)
    shutil.rmtree(tmp_dir)
    

if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Micromegas Image extraction from NSWL1 TTree")
    parser.add_argument("path", action="store", type=Path, default="MMImages.root",
                     help="input Tree data file, generated by the wrangling script")
    parser.add_argument("--tmp-dir", action="store", default="./images/", type=Path, 
                        help="path to temporary storage folder")
    parser.add_argument("-j", action="store", default=None, type=int,
                     help="number of parallel processes (unses all available unless "
                     "specified otherwise)")
    parser.add_argument("-B", "--branch", action="store", default="MM_Image", type=str, 
                        help="name of the branch to be extracted")
    parser.add_argument("-T", "--tree", action="store", default="MMTriggerData", type=str, 
                        help="name of the desired Tree in the input file")
    parser.add_argument("-O", "--output", action="store", default="./images.npz", type=Path,
                        help="path of the output file")
    parser.add_argument("-C", "--chunk-size", action="store", default=50, type=int, 
                        help="number of events to be processed for each chunk")
    args = parser.parse_args()

    n = get_tree_entries(args.path, args.tree)
    slices = np.arange(0,n,args.chunk_size)
    if slices[-1] < n:
        slices = np.append(slices,n)
    slices = [(a,b) for a,b in zip(slices[:-1], slices[1:])]

    base_config = {"tree": args.tree,
                   "file": args.path,
                   "branch": args.branch,
                   "tmp_dir": args.tmp_dir}
    configs = [{**base_config, **{"slc":s, "no":no}} 
                for no, s in enumerate(slices)]

    with concurrent.futures.ProcessPoolExecutor(max_workers=args.j) as executor:
        list(tqdm.tqdm(executor.map(run, configs), total=len(configs)))
           
    merge(args.tmp_dir, args.output)
